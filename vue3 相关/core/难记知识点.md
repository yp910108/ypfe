#### 关于 props

- attribute 的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除
- 如果传入 `null`，那么该 prop 的 `default` 值不会生效，会被设置为 `null`
- 如果传入 `undefined`，那么该 prop 的 `default` 会生效
- 对于 `Boolean` 类型的 prop：1、如果 attribute 的值不指定或指定为空字符串（`disabled=""`），那么 prop 为 `true`；2、如果传入 `disabled` 或者不指定，无论声明类型的顺序如何，值都会按照 `Boolean` 类型的特殊转换规则进行转换；3、如果传入 `disabled=""`，当 prop 的 `type` 设置为 `[Boolean, String]` 时，值为 `true`，当 prop 的 `type` 设置为 `[String, Boolean]` 时，值为空字符串

#### 关于 attribute 透传

- 对于一般的 attribute，透传的 attribute 会覆盖当前组件的 attribute
- class 的合并规则是在当前 class 后面追加传入的 class。style 的合并规则是传入的样式属性会覆盖当前组件对应的样式属性
- `v-on` 事件监听器的合并规则是当前的监听器和传入的监听器都会被触发，并且当前的监听器会被先触发

```html
<!-- App.vue -->
<script setup lang="ts">
import MyButton from "./components/MyButton.vue";

const handleClick = () => {
  console.log("click parent...");
};
</script>

<template>
  <MyButton
    data-id="parent"
    class="large"
    style="color: orange"
    @click="handleClick"
  />
</template>

<!-- MyButton.vue -->
<script setup lang="ts">
const handleClick = () => {
  console.log("click self...");
};
</script>

<template>
  <button
    data-id="self"
    class="btn"
    style="font-size: 16px; color: #333"
    @click="handleClick"
  >
    click me
  </button>
</template>

<!-- 最后渲染出的 DOM 结果 -->
<button
  data-id="parent"
  class="btn large"
  style="font-size: 16px; color: orange"
>
  click me
</button>
<!-- 浏览器先打印 click self...，然后打印 click parent... -->
```

当不设置 `inheritAttrs: false` 使用 `v-bind="$attrs"` 时，attribute 会被重复设置，但是 `v-on` 事件监听器只会执行一次，与预期的结果不一样。

```html
<!-- App.vue -->
<script setup lang="ts">
import MyButton from "./components/MyButton.vue";

const handleClick = () => {
  console.log("click parent...");
};
</script>

<template>
  <MyButton
    data-id="parent"
    class="large"
    style="color: orange"
    @click="handleClick"
  />
</template>

<!-- MyButton.vue -->
<script setup lang="ts">
const handleClick = () => {
  console.log("click self...");
};
</script>

<template>
  <button
    v-bind="$attrs"
    data-id="self"
    class="btn"
    style="font-size: 16px; color: #333"
    @click="handleClick"
  >
    click me
  </button>
</template>

<!-- 最后渲染出的 DOM 结果 -->
<button
  data-id="parent"
  class="large btn large"
  style="color: orange; font-size: 16px"
>
  click me
</button>
<!-- 浏览器先打印 click parent...，然后打印 click self... -->
```

```html
<!-- App.vue -->
<script setup lang="ts">
import MyButton from "./components/MyButton.vue";

const handleClick = () => {
  console.log("click parent...");
};
</script>

<template>
  <MyButton
    data-id="parent"
    class="large"
    style="color: orange"
    @click="handleClick"
  />
</template>

<!-- MyButton.vue -->
<script setup lang="ts">
const handleClick = () => {
  console.log("click self...");
};
</script>

<template>
  <button
    data-id="self"
    class="btn"
    style="font-size: 16px; color: #333"
    @click="handleClick"
    v-bind="$attrs"
  >
    click me
  </button>
</template>

<!-- 最后渲染出的 DOM 结果 -->
<button
  data-id="parent"
  class="btn large large"
  style="font-size: 16px; color: orange"
>
  click me
</button>
<!-- 浏览器先打印 click self...，然后打印 click parent... -->
```

当组件中存在多个根元素时，浏览器会报 `[Vue warn]: Extraneous non-props attributes (msg) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.` 的警告，需要显示的调用 `v-bind="$attrs"`，当设置 `v-bind="$attrs"` 的子元素位于当前元素之外时（比如调用组件时通过 `<slot>` 传入）：

```html
<!-- BaseLink.vue -->
<script lang="ts">
export default {
  name: "BaseLink",
};
</script>

<template>
  <div class="base-link"></div>
  <slot></slot>
</template>
```

```html
<!-- AppLink.vue -->
<script lang="ts">
import BaseLink from "./BaseLink.vue";

export default {
  name: "AppLink",
  inheritAttrs: false,
  components: { BaseLink },
  props: ["msg"],
};
</script>

<template>
  <base-link v-bind="$props">
    <!-- 此处 `v-bind="$attrs"` 是必须的，相当于在 BaseLink 内部显示的调用了 `v-bind="$attrs"` -->
    <div v-bind="$attrs" class="extra">
      <slot></slot>
    </div>
  </base-link>
</template>
```

```html
<!-- App.vue -->
<script setup lang="ts">
import AppLink from "./AppLink.vue";
</script>

<template>
  <app-link msg="this is msg">app link</app-link>
</template>
```

#### 各种烦人的执行顺序

生命周期（无 `<KeepAlive />` 时：

```js
/** 组件加载时 **/
// parent onBeforeMount...
// child onBeforeMount...
// child onMounted...
// parent onMounted...

/** 父组件数据更新时 **/
// parent onBeforeUpdate...
// child onBeforeUpdate... // 无论是否用到了父组件的数据、或者设置了 inheritAttrs: false，只要父组件传了，就会触发
// child onUpdated... // 无论是否用到了父组件的数据、或者设置了 inheritAttrs: false，只要父组件传了，就会触发
// parent onUpdated...

/** 子组件数据更新时 **/
// child onBeforeUpdate...
// child onUpdated...

/** 组件销毁时 **/
// parent onBeforeUnmount...
// child onBeforeUnmount...
// child onUnmounted...
// parent onUnmounted...
```

生命周期（有 `<KeepAlive />` 时：

```js
/** 组件加载时 **/
// parent onBeforeMount...
// child onBeforeMount...
// child onMounted...
// parent onMounted...
// child onActivated...
// parent onActivated...

/** 父组件数据更新时 **/
// parent onBeforeUpdate...
// child onBeforeUpdate... // 无论是否用到了父组件的数据、或者设置了 inheritAttrs: false，只要父组件传了，就会触发
// child onUpdated... // 无论是否用到了父组件的数据、或者设置了 inheritAttrs: false，只要父组件传了，就会触发
// parent onUpdated...

/** 子组件数据更新时 **/
// child onBeforeUpdate...
// child onUpdated...

/** 当组件失活时 **/
// child onDeactivated...
// parent onDeactivated...

/** 当组件激活时： **/
// child onActivated...
// parent onActivated...

/** 组件销毁时（<KeepAlive /> 时无法触发组件销毁，但是当组件处于失活状态时，如果将组件从 <KeepAlive /> 的 include 中干掉，会触发组件销毁） **/
// parent onBeforeUnmount...
// child onBeforeUnmount...
// child onUnmounted...
// parent onUnmounted...
```

vue2 生命周期（无 `<keep-alive />` 时）：

```js
/** 组件加载时 **/
// parent before create...
// parent created...
// parent before mount...

// child before create...
// child created...
// child before mount...
// child mounted...

// parent mounted...


/** 父组件数据更新时 **/
// parent before update...
// child before update... // 如果用到了父组件的数据
// child updated... // 如果用到了父组件的数据
// parent updated...


/** 子组件数据更新时 **/
// child before update...
// child updated...


/** 组件销毁时 **/
// parent before destroy...
// child before destroy...
// child destroyed...
// parent destroyed...
```

vue2 生命周期（有 `<keep-alive />` 时）：

```js
/** 组件加载时 **/
// parent before create...
// parent created...
// parent before mount...

// child before create...
// child created...
// child before mount...
// child mounted...

// parent mounted...

// child activated...
// parent activated...


/** 父组件数据更新时 **/
// parent before update...
// child before update... // 如果用到了父组件的数据
// child updated... // 如果用到了父组件的数据
// parent updated...


/** 子组件数据更新时 **/
// child before update...
// child updated...


/** 当组件失活时 **/
// child deactivated...
// parent deactivated...


/** 当组件激活时： **/
// child activated...
// parent activated...

/** 组件销毁时（<keep-alive /> 时无法触发组件销毁，但是当组件处于失活状态时，如果将组件从 <keep-alive /> 的 include 中干掉，会触发组件销毁） **/
// parent before destroy...
// child before destroy...
// child destroyed...
// parent destroyed...
```

#### `<script setup>` 或者 async setup() 中使用 await

`<script setup>` 中顶层 `await` 表达式会自动让该组件成为一个异步依赖。因此 `async setup()` 以及顶层中带有 `await` 的 `<script setup>` 需要配合 `<Suspense>` 使用。

当在 `async setup()` 中调用生命周期时，需要把生命周期放在第一个 `await` 前面：

```html
<script setup lang="ts">
import { ref, onMounted } from "vue";

const fetch = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(123);
    }, 1000);
  });
};

const count = ref(0);

const res = await fetch();
console.log(res);

onMounted(() => {
  count.value = 1;
});
</script>

<template>
  <div class="count">{{ count }}</div>
</template>
```

```js
import { ref, onMounted } from 'vue'

const fetch = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(123)
    }, 1000)
  })
}

export default {
  async setup() {
    const count = ref(0)

    // must be called before the first `await`
    onMounted(() => {
      count.value = 1
    })

    const res = await fetch()
    console.log(res)

    return { count }
  },
  template: `<div class="count">{{ count }}</div>`,
}
```

当在 `async setup()` 中使用组合函数时，如果组合函数中用到了生命周期，也需要把组合函数的调用放在第一个 `await` 前面：

```html
<script setup lang="ts">
import { useMouse } from "../hooks/mouse";

const fetch = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(123);
    }, 3000);
  });
};

const res = await fetch();
console.log(res);

const { x, y } = useMouse();
</script>

<template>Mouse is at: {{ x }}, {{ y }}</template>
```

```js
import { useMouse } from './hooks/mouse.js'

const fetch = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(123)
    }, 3000)
  })
}

export default {
  async setup() {
    // must be called before the first `await`
    const { x, y } = useMouse()

    const res = await fetch()
    console.log(res)

    return { x, y }
  },
  template: `Mouse is at: {{ x }}, {{ y }}`,
}
```

当在 `async setup()` 中使用 `provide/inject` 时，也需要把组合函数的调用放在第一个 `await` 前面：

```js
import { ref, provide } from 'vue'
import Child from './child.js'

function fetch() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(123)
    }, 1000)
  })
}

export default {
  components: {
    Child,
  },
  async setup() {
    const message = ref('hello')

    // must be called before the first `await`
    provide('message', message)

    const res = await fetch()
    console.log(res)

    return { message }
  },
  template: `
    <input v-model="message" />
    <Child />
  `,
}
```

#### 调用子组件方法

在 vue2 中使用 `$refs` 调用子组件方法时，不能使用方法名调用，但可以使用内联表达式调用：

```html
<!-- 不能写成 `@click="$refs.test.show"`，否则会报错："TypeError: Cannot read properties of undefined (reading 'show')"  -->
<template>
  <div class="wrapper">
    <test ref="test" />
    <button @click="$refs.test.show()">click me</button>
  </div>
</template>

<script>
import Test from './views/Test'

export default {
  components: {
    Test
  }
}
</script>
```

在 vue3 中使用 `ref` 调用子组件方法时，两种方式都可以：

```html
<!-- 也可以写成 `@click="testTs?.show"`-->
<script setup lang="ts">
import { ref } from "vue";
import Modal from "./components/Modal.vue";

const modal = ref<InstanceType<typeof Modal>>();
</script>

<template>
  <Modal ref="modal" />
  <button @click="modal?.show()">click me</button>
</template>
```

#### 渲染函数 & JSX 中使用修饰符

对于 .passive、.capture 和 .once 事件修饰符，可以使用驼峰写法将他们拼接在事件名后面，不支持 withModifiers：

```tsx
import { defineComponent, h } from "vue";

{
  /* <input @change.once="handleChange" /> */
}

export default defineComponent({
  setup() {
    const handleChange = () => {
      console.log("change...");
    };

    // return () =>
    //   h("input", {
    //     onChangeOnce: handleChange,
    //   });

    return () => <input onChangeOnce={handleChange} />;
  },
});
```

对于事件和按键修饰符，可以使用 withModifiers 函数，不支持 .self：

```tsx
import { defineComponent, h, withModifiers } from "vue";

{
  /* <div @click.self="handleClick">
  click div
  <button>click button</button>
</div> */
}

// 对于事件和按键修饰符，可以使用 withModifiers 函数，不支持 .self
export default defineComponent({
  setup() {
    const handleClick = withModifiers(() => {
      console.log("div clicked.");
    }, ["self"]);

    // return () =>
    //   h("div", { onClick: handleClick }, [
    //     "click div",
    //     h("button", "click button"),
    //   ]);

    return () => (
      <div onClick={handleClick}>
        click div
        <button>click button</button>
      </div>
    );
  },
});
```

#### DOM 更新前会触发 `render` 函数，DOM 更新后会触发 `onUpdated` 钩子函数

> 注意：不是状态更新，是 DOM 更新

```tsx
import { defineComponent, h, ref, onMounted, onUpdated } from "vue";

export default defineComponent({
  setup() {
    const count = ref(0);

    console.log("setup...");

    onMounted(() => {
      console.log("mounted...");
    });

    onUpdated(() => {
      console.log("updated...");
    });

    return () => {
      console.log("render...");
      return <button onClick={() => count.value++}>{count.value}</button>;
    };
  },
});
```

```js
/** 初次加载时 **/
// setup...
// render...
// mounted...


/** 状态改变时 **/
// render...
// updated...
```

#### DOM 能否更新以及是否响应式

如果解构了 `props` 对象，解构出的变量将会丢失响应性：

```html
<script lang="ts">
import { defineComponent, computed } from "vue";

export default defineComponent({
  props: ["msg"],
  setup({ msg }) {
    // message 无法获取最新值
    const message = computed(() => msg);
    return { message };
  },
});
</script>

<template>
  <div>{{ message }}</div>
</template>
```

```html
<script lang="ts">
import { defineComponent, computed } from "vue";

export default defineComponent({
  props: ["msg"],
  setup(props) {
    // message 可以获取最新值
    const message = computed(() => props.msg);
    return { message };
  },
});
</script>

<template>
  <div>{{ message }}</div>
</template>
```

虽然 attrs 对象总是反映为最新的透传 attribute，但它并不是响应式的，所以不能通过侦听器去监听它的变化。以下两种方式都可以触发 dom 更新：

```html
<template>
  <div>{{ $attrs.msg }}</div>
</template>
```

```html
<script lang="ts">
import { defineComponent, computed } from "vue";

export default defineComponent({
  setup(_, { attrs }) {
    const message = computed(() => {
      return attrs.msg;
    });
    return { message };
  },
});
</script>

<template>
  <div>{{ message }}</div>
</template>
```

attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。以下方式无法触发 dom 更新：

```html
<script lang="ts">
import { defineComponent, computed } from "vue";

export default defineComponent({
  setup(_, { attrs }) {
    const { msg } = attrs;
    const message = computed(() => msg);
    return { message };
  },
});
</script>

<template>
  <div>{{ message }}</div>
</template>
```

可以通过解构的方式使用 slots，因为 watch 的第一个参数可以是 一个 getter 函数，所以 watch slots 中的属性可以，watch slots 不可以：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import Test from "./components/TestT/index";

const message = ref("this is app.");

const handleToggleMsg = () => {
  message.value =
    message.value === "this is app." ? "this is vue." : "this is app.";
};
</script>

<template>
  <Test>
    <template #custom="msg">{{ message }} - {{ msg }}</template>
  </Test>
  <button @click="handleToggleMsg">{{ message }}</button>
</template>
```

```tsx
// index.tsx
import { defineComponent, watch } from "vue";

export default defineComponent({
  setup(_, { slots }) {
    const { custom } = slots;
    watch(custom!, (newCustom) => {
      // 当 App.vue 中 message 变化时，此处会打印 custom 返回的 vnodes
      console.log(newCustom);
    });
    // 当 App.vue 中 message 变化时，此处也会随之改变
    return () => <div>{custom!("this is custom.")}</div>;
  },
});
```

```html
<!-- index.vue -->
<script lang="ts">
export default {
  watch: {
    "$slots.custom"(newVal) {
      // 当 App.vue 中 message 变化时，此处不会打印
      console.log(newVal);
    },
  },
};
</script>

<template>
  <div>
    <slot name="custom" msg="this is custom."></slot>
  </div>
</template>
```

注入（provide）绑定并非响应式的，如果要注入的值是一个响应式对象，那么这个对象上的属性将会保留响应性：

```html
<!-- App.vue -->
<script lang="ts">
import Test from "./components/TestT/index.vue";

export default {
  components: {
    Test,
  },
  data() {
    return {
      msg: "this is app.",
    };
  },
  provide() {
    return {
      msg: this.msg,
    };
  },
};
</script>

<!-- index.vue -->
<template>
  <Test />
  <button @click="msg = 'this is vue.'">{{ msg }}</button>
</template>

<script lang="ts">
export default {
  inject: ["msg"],
  watch: {
    msg(newMsg) {
      // 无法触发 watch
      console.log(newMsg);
    },
  },
};
</script>

<template>
  <!-- dom 无法更新 -->
  <div>{{ msg }}</div>
</template>
```

```html
<!-- App.vue -->
<script lang="ts">
import Test from "./components/TestT/index.vue";

export default {
  components: {
    Test,
  },
  data() {
    return {
      msg: "this is app.",
    };
  },
  provide() {
    return {
      app: this,
    };
  },
};
</script>

<template>
  <Test />
  <button @click="msg = 'this is vue.'">{{ msg }}</button>
</template>

<!-- index.vue -->
<script lang="ts">
export default {
  inject: ["app"],
  watch: {
    "app.msg"(newMsg) {
      // 可以触发 watch
      console.log(newMsg);
    },
  },
};
</script>

<template>
  <!-- dom 可以更新 -->
  <div>{{ app.msg }}</div>
</template>
```

```html
<!-- App.vue -->
<script lang="ts">
import Test from "./components/TestT/index.vue";

export default {
  components: {
    Test,
  },
  data() {
    return {
      info: {
        msg: "this is app.",
      },
    };
  },
  provide() {
    return {
      info: this.info,
    };
  },
};
</script>

<template>
  <Test />
  <button @click="info.msg = 'this is vue.'">{{ info.msg }}</button>
</template>

<!-- index.vue -->
<script lang="ts">
export default {
  inject: ["info"],
  watch: {
    "info.msg"(newMsg) {
      // 可以触发 watch
      console.log(newMsg);
    },
  },
};
</script>

<template>
  <!-- dom 可以更新 -->
  <div>{{ info.msg }}</div>
</template>
```

#### 各种烦人的大小写

HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写：

```html
<TDiv viewBox="this is view box"></TDiv>

<!-- 解析为 <tdiv viewbox="this is view box"></tdiv> -->
```

类似 svg 标签使用 viewBox 这样特定的的属性名称，则可以区分大小写：

```html
<svg viewBox="this is view box" TTitle="this is t title"></svg>

<!-- 解析为 <svg viewBox="this is view box" ttitle="this is t title"></svg> -->
```

为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` 引用：

```ts
// 注册组件
app.component("MyComponent", {});
```

```html
<!--模板中-->
<MyComponent />
<my-component></my-component>
```

attribute 名称会在浏览器中解析为小写，但是会原样传递给 \$attrs：

```html
<Test :t-title="'this is t title.'" />
<!-- 解析为 <div class="test" t-title="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 t-title -->

<Test :ttitle="'this is t title.'" />
<!-- 解析为 <div class="test" ttitle="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 ttitle -->

<Test :tTitle="'this is t title.'" />
<!-- 解析为 <div class="test" ttitle="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 tTitle -->

<Test :T-title="'this is t title.'" />
<!-- 解析为 <div class="test" t-title="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 T-title -->

<Test :T-Title="'this is t title.'" />
<!-- 解析为 <div class="test" t-title="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 T-Title -->

<Test :TTitle="'this is t title.'" />
<!-- 解析为 <div class="test" ttitle="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 TTitle -->

<Test :Ttitle="'this is t title.'" />
<!-- 解析为 <div class="test" ttitle="this is t title.">this is test.</div> -->
<!-- $attrs 解析为 Ttitle -->
```

prop 名称会在浏览器中解析为小写，但是转化为 camelCase（转化规则为将 - 后的第一个字母转化为大写）传递给 \$props：

```html
<!-- props 声明的名称为 t-title 或者 tTitle -->

<Test :t-title="'this is t title.'" />
<Test :t-Title="'this is t title.'" />
<Test :tTitle="'this is t title.'" />
<!-- $props 解析为 tTitle -->

<!-- props 声明的名称为 TTitle -->
<Test :T-title="'this is t title.'" />
<Test :T-Title="'this is t title.'" />
<Test :TTitle="'this is t title.'" />
<!-- $props 解析为 TTitle -->

<!-- props 声明的名称为 Ttitle -->
<Test :Ttitle="'this is t title.'" />
<!-- $props 解析为 Ttitle -->
```

作用域插槽会将 kebab-case 格式的属性名转化为 camelCase 的格式：

```html
<!-- App.vue -->
<script setup lang="ts">
import Test from "./components/TestT/index.vue";
</script>

<template>
  <Test>
    <template #header="{ headerMsg }">
      <div class="header">
        {{ headerMsg }}
      </div>
    </template>
    <template #default="{ defaultMsg }">
      <h1 class="default">{{ defaultMsg }}</h1>
    </template>
    <template #footer="{ footerMsg }">
      <div class="footer">
        {{ footerMsg }}
      </div>
    </template>
  </Test>
</template>
```

```html
<!-- index.vue -->
<template>
  <div class="test">
    <slot name="header" header-msg="this is header slot."></slot>
    <slot name="default" default-msg="this is default slot."></slot>
    <slot name="footer" footer-msg="this is footer slot."></slot>
  </div>
</template>
```

#### 关于 `v-model`

`v-model:xxx` 会展开为 `:xxx` 和 `@update:xxx`：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import TestT from "./components/TestT/index.vue";

const num = ref(0);

const handleUpdateNum = (newNum: any) => {
  num.value = newNum;
};
</script>

<template>
  <!-- <TestT v-model:num="num" /> -->
  <TestT :num="num" @update:num="handleUpdateNum" />
</template>
```

```html
<!-- index.vue -->
<script setup lang="ts">
import { useAttrs } from "vue";

const attrs = useAttrs();
const props = defineProps(["num"]);
const emit = defineEmits(["update:num"]);

console.log("attrs is: ");
console.log(attrs);

console.log("props is: ");
console.log(props);

const handleClick = () => {
  emit("update:num", 123);
};
</script>

<template>
  <button @click="handleClick">{{ num }}</button>
</template>
```

`@update:xxx` 等价于 `onUpdate:xxx`，所以上面的示例也可以这样写：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import TestT from "./components/TestT/index.vue";

const num = ref(0);

const handleUpdateNum = (newNum: any) => {
  num.value = newNum;
};
</script>

<template>
  <!-- <TestT v-model:num="num" /> -->
  <!-- <TestT :num="num" @update:num="handleUpdateNum" /> -->
  <TestT :num="num" :onUpdate:num="handleUpdateNum" />
</template>
```

```html
<!-- index.vue -->
<script setup lang="ts">
import { useAttrs } from "vue";

const attrs = useAttrs();
const props = defineProps(["num"]);
const emit = defineEmits(["update:num"]);

console.log("attrs is: ");
console.log(attrs);

console.log("props is: ");
console.log(props);

const handleClick = () => {
  emit("update:num", 123);
};
</script>

<template>
  <button @click="handleClick">{{ num }}</button>
</template>
```

混淆：如果想要通过 `:on-update:xxx` 的形式监听事件，则子组件需要声明 `onUpdate:xxx` 或 `on-update:num` 的 props，但是必须通过 `props['onUpdate:xxx']()` 触发（因为 vue 会将 kebab-case 格式的属性名转化为 camelCase 格式）：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import TestT from "./components/TestT/index.vue";

const num = ref(0);

const handleUpdateNum = (newNum: any) => {
  num.value = newNum;
};
</script>

<template>
  <!-- <TestT v-model:num="num" /> -->
  <!-- <TestT :num="num" @update:num="handleUpdateNum" /> -->
  <!-- <TestT :num="num" :onUpdate:num="handleUpdateNum" /> -->
  <TestT :num="num" :on-update:num="handleUpdateNum" />
</template>
```

```html
<!-- index.vue -->
<script setup lang="ts">
import { useAttrs } from "vue";

const attrs = useAttrs();
const props = defineProps([
  "num",
  "onUpdate:num" /* 也可以声明为 on-update:num */,
]);

console.log("attrs is: ");
console.log(attrs);

console.log("props is: ");
console.log(props);

const handleClick = () => {
  // 无论 props 如何声明，props["on-update:num"](123) 都无法触发更新
  props["onUpdate:num"](123);
};
</script>

<template>
  <button @click="handleClick">{{ num }}</button>
</template>
```

进阶：`v-model:xxx="xxx" @update:xxx="handleUpdateXxx"` 会被 Vue 转化为 `[(newXxx) => xxx.value = newXxx, handleUpdateXxx]` 的 `onUpdate:xxx` props：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import TestT from "./components/TestT/index.vue";

const num = ref(0);

const handleUpdateNum = (newNum: any) => {
  console.log(newNum);
};
</script>

<template>
  <!-- <TestT v-model:num="num" /> -->
  <!-- <TestT :num="num" @update:num="handleUpdateNum" /> -->
  <!-- <TestT :num="num" :onUpdate:num="handleUpdateNum" /> -->
  <!-- <TestT :num="num" :on-update:num="handleUpdateNum" /> -->
  <TestT v-model:num="num" @update:num="handleUpdateNum" />
</template>
```

```html
<!-- index.vue -->
<script setup lang="ts">
import { useAttrs } from "vue";

const attrs = useAttrs();
const props = defineProps(["num", "onUpdate:num"]);

console.log("attrs is: ");
console.log(attrs);

console.log("props is: ");
console.log(props);

const handleClick = () => {
  const update = props["onUpdate:num"];
  if (Array.isArray(update)) {
    for (const fn of update) {
      fn(123);
    }
  } else {
    update(123);
  }
};
</script>

<template>
  <button @click="handleClick">{{ num }}</button>
</template>
```

#### 关于 `v-for`

Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，**Vue 不会随之移动 DOM 元素的顺序**，而是就地更新每个元素，确保它们**在原本指定的索引位置上渲染**：

```html
<script setup lang="ts">
import { ref } from "vue";

const list = ref([
  { id: 0, value: "value-0" },
  { id: 1, value: "value-1" },
  { id: 2, value: "value-2" },
]);

const handleClick = () => {
  list.value.push(list.value.shift()!);
};
</script>

<template>
  <!-- 当 list 顺序改变时，DOM 的顺序不会随之改变，会在原本位置进行重新渲染 -->
  <ul>
    <li v-for="(item, index) of list" :key="index">
      <input
        :value="item.value"
        @blur="(e) => ((e.target as any).style.background = 'red')"
      />
    </li>
  </ul>
  <button @click="handleClick">click</button>
</template>
```

默认模式是高效的，但只适用于**列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况**：

```html
<!-- App.vue -->
<script setup lang="ts">
import { ref } from "vue";
import Test from "./components/TestT/index.vue";

const list = ref([
  { id: 0, value: "value-0" },
  { id: 1, value: "value-1" },
  { id: 2, value: "value-2" },
]);

const handleClick = () => {
  list.value.push(list.value.shift()!);
};
</script>

<template>
  <ul>
    <li v-for="(item, index) of list" :key="index">
      <Test />
    </li>
  </ul>
  <button @click="handleClick">click</button>
</template>
```

```html
<!-- index.vue -->
<script setup lang="ts">
import { ref } from "vue";

const message = ref();
</script>

<template>
  <!-- 这里的临时 DOM 状态是表单输入值（上例中的 background 也是临时 DOM 状态），子组件状态是 message -->
  <input />
  {{ message }}
  <button @click="message = 'changed.'">click</button>
</template>
```

#### v-model 与 input、textarea、select

`v-model` 会根据所使用的元素自动使用对应的 DOM 属性和事件组合:

*   文本类型的 `<input>` 和 `<textarea>` 元素会绑定 `value` property 并侦听 `input` 事件；
*   `<input type="checkbox">` 和 `<input type="radio">` 会绑定 `checked` property 并侦听 `change` 事件；
*   `<select>` 会绑定 `value` property 并侦听 `change` 事件。

```html
<script setup lang="ts">
import { ref } from "vue";

const text = ref("Edit me");
const checked = ref(true);
const checkedNames = ref(["Jack"]);
const picked = ref("One");
const selected = ref("b");
const multiSelected = ref(["b"]);

const handleMultiCheckboxChange = (event: any) => {
  const value = event.target.value;
  const checked = event.target.checked;
  if (checked) {
    checkedNames.value.push(value);
  } else {
    checkedNames.value.splice(checkedNames.value.indexOf(value), 1);
  }
};

const handleMultiSelectedChange = (event: any) => {
  const options = event.target.querySelectorAll("option");
  const value = [...options]
    .filter((option: any) => option.selected)
    .map((option: any) => option.value);
  multiSelected.value = value;
};
</script>

<template>
  <!-- <h2>Text Input</h2>
  <input v-model="text" />{{ text }}

  <h2>Checkbox</h2>
  <input v-model="checked" id="checkbox" type="checkbox" />
  <label for="checkbox">Checked: {{ checked }}</label>

  <h2>Multi Checkbox</h2>
  <input v-model="checkedNames" id="jack" type="checkbox" value="Jack" />
  <label for="jack">Jack</label>
  <input v-model="checkedNames" id="john" type="checkbox" value="John" />
  <label for="john">John</label>
  <input v-model="checkedNames" id="mike" type="checkbox" value="Mike" />
  <label for="mike">Mike</label>
  <div>Checked names: {{ checkedNames }}</div>

  <h2>Radio</h2>
  <input v-model="picked" id="one" type="radio" value="One" />
  <label for="one">One</label>
  <br />
  <input v-model="picked" id="two" type="radio" value="Two" />
  <label for="two">Two</label>
  <br />
  <span>Picked: {{ picked }}</span>

  <h2>Select</h2>
  <select v-model="selected">
    <option value="a">A</option>
    <option value="b">B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>

  <h2>Multi Select</h2>
  <select v-model="multiSelected" multiple style="width: 100px">
    <option value="a">A</option>
    <option value="b">B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ multiSelected }}</span> -->

  <h2>Text Input</h2>
  <input
    :value="text"
    @input="(event) => (text = (event.target as any).value)"
  />
  {{ text }}

  <h2>Checkbox</h2>
  <input
    id="checkbox"
    type="checkbox"
    :checked="checked"
    @change="(event: any) => (checked = event.target.checked)"
  />
  <label for="checkbox">Checked: {{ checked }}</label>

  <h2>Multi Checkbox</h2>
  <input
    id="jack"
    type="checkbox"
    value="Jack"
    :checked="checkedNames.includes('Jack')"
    @change="handleMultiCheckboxChange"
  />
  <label for="jack">Jack</label>
  <input
    id="john"
    type="checkbox"
    value="John"
    :checked="checkedNames.includes('John')"
    @change="handleMultiCheckboxChange"
  />
  <label for="john">John</label>
  <input
    id="mike"
    type="checkbox"
    value="Mike"
    :checked="checkedNames.includes('Mike')"
    @change="handleMultiCheckboxChange"
  />
  <label for="mike">Mike</label>
  <div>Checked names: {{ checkedNames }}</div>

  <h2>Radio</h2>
  <input
    id="one"
    type="radio"
    value="One"
    :checked="picked === 'One'"
    @change="(event: any) => (picked = event.target.value)"
  />
  <label for="one">One</label>
  <br />
  <input
    id="two"
    type="radio"
    value="Two"
    :checked="picked === 'Two'"
    @change="(event: any) => (picked = event.target.value)"
  />
  <label for="two">Two</label>
  <br />
  <span>Picked: {{ picked }}</span>

  <!-- 在原生 select 中，如果 option 没有设置 value，则会将元素内容设置为 value -->
  <h2>Select</h2>
  <select
    :value="selected"
    @change="(event: any) => (selected = event.target.value)"
  >
    <option value="a">A</option>
    <option value="b">B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>

  <!-- 这里不能给 select 设置 `:value="multiSelected"`  -->
  <h2>Multi Select</h2>
  <select multiple style="width: 100px" @change="handleMultiSelectedChange">
    <option value="a" :selected="multiSelected.includes('a')">A</option>
    <option value="b" :selected="multiSelected.includes('b')">B</option>
    <option :selected="multiSelected.includes('C')">C</option>
  </select>
  <span>Selected: {{ multiSelected }}</span>
</template>
```

#### reactive、ref、props、computed、toRefs

`reactive` 解构会丢失响应性：

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ state.count }}</button>
</template>

<script setup lang="ts">
import { reactive } from "vue";

const state = reactive({ count: 0 });

const increment = () => {
  state.count++;
};
</script>
```

```html
<!-- 丢失响应 -->
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup lang="ts">
import { reactive } from "vue";

const state = reactive({ count: 0 });

let { count } = state;

const increment = () => {
  count++;
};
</script>
```

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup lang="ts">
import { reactive, toRefs } from "vue";

const state = reactive({ count: 0 });

let { count } = toRefs(state);

console.log(count.value === state.count); // true

const increment = () => {
  count.value++;
};
</script>
```

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup lang="ts">
import { computed, reactive } from "vue";

const state = reactive({ count: 0 });

const count = computed(() => {
  const { count } = state; // 这里可以解构
  return count * 2;
});

const increment = () => {
  state.count++;
};
</script>
```

`reactive` 和 `ref` 配合：

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ countRef }}</button>
</template>

<script setup lang="ts">
import { reactive, ref } from "vue";

const countRef = ref(0);

const state = reactive({ count: countRef });

const increment = () => {
  state.count++;
};
</script>
```

```html
<!-- 丢失响应 -->
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup lang="ts">
import { reactive, ref } from "vue";

const countRef = ref(0);

const state = reactive({ count: countRef });

let { count } = state;

const increment = () => {
  count++;
};
</script>
```

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup lang="ts">
import { reactive, ref, toRefs } from "vue";

const countRef = ref(0);

const state = reactive({ count: countRef });

let { count } = toRefs(state);

console.log(count.value === countRef.value);

const increment = () => {
  count.value++;
};
</script>
```

`setup` 中的 `props`：

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
  <foo :count="count" />
</template>

<script setup lang="ts">
import { defineComponent, ref } from "vue";

const Foo = defineComponent({
  name: "Foo",
  props: ["count"],
  template: `
    <div style="color: red">{{ count }}</div>
  `,
});

const count = ref(0);

const increment = () => {
  count.value++;
};
</script>
```

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
  <foo :count="count" />
</template>

<script setup lang="ts">
import { computed, defineComponent, ref } from "vue";

const Foo = defineComponent({
  name: "Foo",
  props: ["count"],
  setup(props) {
    const double = computed(() => {
      return props.count * 2;
    });
    return { double };
  },
  template: `
    <div style="color: red">{{ double }}</div>
  `,
});

const count = ref(0);

const increment = () => {
  count.value++;
};
</script>
```

```html
<!-- 丢失响应 -->
<template>
  <button @click="increment">{{ count }}</button>
  <foo :count="count" />
</template>

<script setup lang="ts">
import { computed, defineComponent, ref } from "vue";

const Foo = defineComponent({
  name: "Foo",
  props: ["count"],
  setup({ count }) {
    const double = computed(() => {
      return count * 2;
    });
    return { double };
  },
  template: `
    <div style="color: red">{{ double }}</div>
  `,
});

const count = ref(0);

const increment = () => {
  count.value++;
};
</script>
```

```html
<!-- 正常响应 -->
<template>
  <button @click="increment">{{ count }}</button>
  <foo :count="count" />
</template>

<script setup lang="ts">
import { computed, defineComponent, ref } from "vue";

const Foo = defineComponent({
  name: "Foo",
  props: ["count"],
  setup(props) {
    const double = computed(() => {
      const { count } = props;
      return count * 2;
    });
    return { double };
  },
  template: `
    <div style="color: red">{{ double }}</div>
  `,
});

const count = ref(0);

const increment = () => {
  count.value++;
};
</script>
```

#### 关于 tsx

原生标签无法渲染对象：

```tsx
import { defineComponent } from 'vue'

export default defineComponent({
  setup() {
    return () => <div class="test">{{ msg: 'this is message.' }}</div>
  }
})
```

自定义组件里面传递对象会被当作插槽：

```tsx
// Test.tsx
import { defineComponent } from 'vue'
import Child from './Child'

export default defineComponent({
  setup() {
    return () => (
      <Child>{{ default: (msg) => msg, custom: (msg) => msg }}</Child>
    )
  }
})
```

```tsx
// Child.tsx
import { defineComponent } from 'vue'

export default defineComponent({
  setup(_props, { slots }) {
    return () => (
      <div class="child">
        <div style="color: green">this is child.</div>
        <div style="color: blue">{slots.default && slots.default('this is default.')}</div>
        <div style="color: orange">{slots.custom && slots.custom('this is custom.')}</div>
      </div>
    )
  }
})
```

传递插槽时，不能通过 `&&` 传递：

```tsx
// Test.tsx
import { defineComponent } from 'vue'
import Child from './Child'

export default defineComponent({
  setup() {
    return () => (
      // 会报：[Vue warn]: Invalid VNode type: undefined (undefined) 的警告
      <Child>{true && { default: (msg) => msg, custom: (msg) => msg }}</Child>
    )
  }
})
```

```tsx
// Child.tsx
import { defineComponent } from 'vue'

export default defineComponent({
  setup(_props, { slots }) {
    // 此时 slots 只有 default
    console.log(slots)
    return () => (
      <div class="child">
        <div style="color: green">this is child.</div>
        <div style="color: blue">{slots.default && slots.default('this is default.')}</div>
        <div style="color: orange">{slots.custom && slots.custom('this is custom.')}</div>
      </div>
    )
  }
})
```

把 slots 上面的函数当作插槽传递时，不能直接传函数：

```html
<!-- App.vue -->
<template>
  <Test>
    <template #custom="msg">
      {{ msg }}
    </template>
  </Test>
</template>

<script setup lang="ts">
// import Test from './Test1.jsx'
import Test from './Test.jsx'
</script>
```

```tsx
// Test.tsx
import { defineComponent } from 'vue'
import Child from './Child'

export default defineComponent({
  setup(_props, { slots }) {
    // 这样可以，渲染结果为 [this is default.]
    // return () => <Child>{{ default: slots.custom }}</Child>
    // 这样也可以，渲染结果为 [this is custom.]
    // return () => <Child>{slots.custom('this is custom.')}</Child>
    // 这样不可以，直接把渲染函数渲染出来了 [(...args) => { if (renderFnWithContext._d) { setBlockTracking(-1); } ...]
    return () => <Child>{slots.custom}</Child>
  }
})
```

```tsx
// Child.tsx
import { defineComponent } from 'vue'

export default defineComponent({
  setup(_props, { slots }) {
    return () => (
      <div class="child">
        <div style="color: green">this is child.</div>
        <div style="color: blue">{slots.default && slots.default('this is default.')}</div>
      </div>
    )
  }
})
```